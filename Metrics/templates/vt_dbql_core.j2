{% set run = namespace(completed=[]) if run is not defined else run %}
{% if not 'vt_dbql_core' in run.completed %}


### ============= SET DEFAULT EXECUTION BEHAVIOR =============
{% set td15           = true  if tdver[:2]=='15'                else false %}
{% set reconcile      = false if reconcile       is not defined else reconcile %}
{% set save_prework   = false if save_prework    is not defined else save_prework %}
{% set process_chunks = 1     if process_chunks  is not defined else process_chunks %}
{% set run.buckets    = false %}  # set to True in the "build dimension" below, if appropriate


### ============= BUILD Included Flag List =============
# this macro will combine "include" and all include_* variables
# into a single "included" variable list for easy testing in SQL
{% import "coa_util.j2" as macro with context %}
{{ macro.build_include_flags(run, ['Default']) }}

# let's output all inclusions, just for reconciliation:
- name: Export all included dimensions, just for reference
  connect: source
  export:
    file: reconcile_dbql_core_settings.csv
    sql: |
      {% for incl in run.included %}
      select * from (select '{{ incl }}'(VARCHAR(128)) as Variable) a{{ loop.index }}
      {% if not loop.last %}
        union all
      {% endif %}
      {% endfor %}



# =================================================================
#     load dimensional table mappings:
{% include "vt_datedriver.j2" %}
{% include "vt_decode_appid.j2" %}
{% include "vt_decode_user.j2" %}
{% include "vt_decode_statement.j2" %}
# =================================================================

# Define Bucket Logic:
{% set bucket_metrics = [ {"metric":"Delaytime_Sec",    "name":"Delaytime_Bucket   ", "format":"%04d", "upperbounds":[1,5,10,30,60,300,600,1800,3600] },
                          {"metric":"ParseTime_Sec",    "name":"ParseTime_Bucket   ", "format":"%04d", "upperbounds":[1,5,10,30,60,300,600,1800,3600] },
                          {"metric":"AMPTime_Sec",      "name":"AMPTime_Bucket     ", "format":"%04d", "upperbounds":[1,5,10,30,60,300,600,1800,3600] },
                          {"metric":"TotalExec_Sec",    "name":"TotalExec_Bucket   ", "format":"%04d", "upperbounds":[1,5,10,30,60,300,600,1800,3600] },
                          {"metric":"TransferTime_Sec", "name":"TransferTime_Bucket", "format":"%04d", "upperbounds":[1,5,10,30,60,300,600,1800,3600] },
                          {"metric":"CPU_Total_Sec",    "name":"CPU_Total_Bucket   ", "format":"%06d", "upperbounds":[1,10,100,1000,10000,100000] },
                          {"metric":"CPU_AMP_Sec",      "name":"CPU_AMP_Bucket     ", "format":"%06d", "upperbounds":[1,10,100,1000,10000,100000] },
                          {"metric":"TotalIOCount_",    "name":"IOCnt_Total_Bucket ", "format":"%07d", "upperbounds":[1,10,100,1000,10000,100000,1000000] },] %}

{% set debug   = False if debug is not defined else debug %}
{% set varchar = 'VARCHAR(128)' if varchar is not defined else varchar %}
{% set bigint  = 'BIGINT' if bigint is not defined else bigint %}
{% set bigdec  = 'DECIMAL(38,4)' if bigdec is not defined else bigdec %}

- name: "Create table: vt_dbql_core (td15 = {{td15}})"
  connect: source
  execute:
    sql: |
      create volatile table vt_dbql_core (
         Site_ID                       {{ varchar }}
        ,LogDate                       DATE format 'yyyy-mm-dd'
        {% if 'LogTS' in run.included %}
        ,LogTS                         TIMESTAMP(0)
        {% endif %}

        /* ====== Dimensions: Usage ======= */
        ,Application                   {{ varchar }}
        ,Application_Use               {{ varchar }}
        ,Application_Company           {{ varchar }}
        ,Statement_Bucket              {{ varchar }}
        ,Statement_Outcome             {{ varchar }}
        {{ ',Workload_Definition           VARCHAR(128) compress (null)' if 'Workload_Definition' in run.included }}
        {{ ',UserName                      VARCHAR(128)' if 'UserName' in run.included }}
        ,UserType                      {{ varchar }}
        ,Organization                  {{ varchar }}
        ,Department                    {{ varchar }}

        /* ====== Dimensions: Flags (optional) ======= */
        {{ ',SubSecond_Flag                BYTEINT compress (null,0,1)' if 'SubSecond_Flag'  in run.included }}
        {{ ',Tactical_Flag                 BYTEINT compress (null,0,1)' if 'Tactical_Flag'   in run.included }}
        {{ ',QueryGrid_Flag                BYTEINT compress (null,0,1)' if 'QueryGrid_Flag'  in run.included }}
        {{ ',Exclude_Performance_Flag      BYTEINT compress (null,0,1)' if 'Exclude_Flag'   in run.included }}
        {{ ',Exclude_VantageUnit_Flag      BYTEINT compress (null,0,1)' if 'Exclude_Flag'   in run.included }}

      {% if "Buckets" in run.included %}
        /* ====== Dimensions: Buckets ====== */
        {%- for metric in bucket_metrics -%}
          {% set run.lb=0 -%}
          {% set compress = ['null', "'" ~ metric.format % 0 ~ " - " ~ metric.format % 0 ~ "'" ] -%}
          {% for ub in metric.upperbounds -%}
          {{ compress.append("'" ~ metric.format %  run.lb ~ " - " ~ metric.format % ub ~ "'" )  or '' }}
          {%- set run.lb = ub -%}
        {% endfor -%}
        {{ compress.append("'" ~ metric.format %  run.lb ~ "+'")  or '' }}
        ,{{ metric.name }}           VARCHAR(32) compress( {{ compress | join(',') }} ){% endfor %}
      {% endif %}


        /* ====== Request and Statement Counts ======= */
        ,  Request_Total_Cnt           {{ bigint }} compress (null, 0)
        ,Statement_Total_Cnt           {{ bigint }} compress (null, 0)
        ,  Request_MultiStatement_Cnt  {{ bigint }} compress (null, 0)
        ,  Request_SubSecond_Cnt       {{ bigint }} compress (null, 0)
        ,Statement_SubSecond_Cnt       {{ bigint }} compress (null, 0)
        ,  Request_Tactical_Cnt        {{ bigint }} compress (null, 0)
        ,Statement_Tactical_Cnt        {{ bigint }} compress (null, 0)
        ,  Request_Error_Cnt           {{ bigint }} compress (null, 0)
        ,Statement_Error_Cnt           {{ bigint }} compress (null, 0)
        ,  Request_Spool_Error_Cnt     {{ bigint }} compress (null, 0)
        ,Statement_Spool_Error_Cnt     {{ bigint }} compress (null, 0)
        ,  Request_TASM_Abort_Cnt      {{ bigint }} compress (null, 0)
        ,Statement_TASM_Abort_Cnt      {{ bigint }} compress (null, 0)
        ,  Request_Abort_Cnt           {{ bigint }} compress (null, 0)
        ,Statement_Abort_Cnt           {{ bigint }} compress (null, 0)
        ,  Request_NoIO_Cnt            {{ bigint }} compress (null, 0)
        ,Statement_NoIO_Cnt            {{ bigint }} compress (null, 0)
        ,  Request_InMem_Cnt           {{ bigint }} compress (null, 0)
        ,Statement_InMem_Cnt           {{ bigint }} compress (null, 0)
        ,  Request_PhysIO_Cnt          {{ bigint }} compress (null, 0)
        ,Statement_PhysIO_Cnt          {{ bigint }} compress (null, 0)
        ,  Request_AllAMP_Cnt          {{ bigint }} compress (null, 0)
        ,Statement_AllAMP_Cnt          {{ bigint }} compress (null, 0)
        ,  Request_Utility_Cnt         {{ bigint }} compress (null, 0)
        ,Statement_Utility_Cnt         {{ bigint }} compress (null, 0)
        ,  Request_QueryGrid_Cnt       {{ bigint }} compress (null, 0)
        ,Statement_QueryGrid_Cnt       {{ bigint }} compress (null, 0)

        /* ====== Metrics: RunTimes ====== */
        ,DelayTime_Sec                 {{ bigdec }} compress (null, 0)
        ,RunTime_Parse_Sec             {{ bigdec }} compress (null, 0)
        ,Runtime_AMP_Sec               {{ bigdec }} compress (null, 0)
        ,RunTime_Total_Sec             {{ bigdec }} compress (null, 0)
        ,TransferTime_Sec              {{ bigdec }} compress (null, 0)

        /* ====== Metrics: CPU & IO ====== */
        ,CPU_Total_Sec                 {{ bigdec }} compress (null, 0)
        ,CPU_AMP_Sec                   {{ bigdec }} compress (null, 0)
        ,IO_Total_CntM                 {{ bigdec }} compress (null, 0)
        ,IO_Physical_CntM              {{ bigdec }} compress (null, 0)
        ,IO_Total_GB                   {{ bigdec }} compress (null, 0)
        ,IO_Physical_GB                {{ bigdec }} compress (null, 0)
        ,IOTA_Used_CntB                {{ bigdec }} compress (null, 0)

        /* ====== Metrics: Other ====== */
        ,Spool_GB                      {{ bigdec }} compress (null, 0)
        ,Returned_Row_Cnt              {{ bigint }}        compress (null, 0)
        ,NumOfActiveAMPs_Avg           {{ bigdec }} compress (null, 0)
        ,QueryGrid_Bytes               {{ bigdec }} compress (null, 0)
        ,CacheMiss_IOCnt_Pct           {{ bigdec }} compress (null, 0)
        ,CacheMiss_IOGB_Pct            {{ bigdec }} compress (null, 0)
        ,CacheMiss_IOCnt_Score         {{ bigdec }} compress (null, 0)
        ,CacheMiss_IOGB_Score          {{ bigdec }} compress (null, 0)
        ,Total_AMPs                    {{ bigint }}
        ,AMP_Use01_Flag                {{ bigint }}  compress (null, 0)
        ,AMP_Use02_Flag                {{ bigint }}  compress (null, 0)
        ,AMP_LT10pct_Flag              {{ bigint }}  compress (null, 0)
        ,AMP_LT50pct_Flag              {{ bigint }}  compress (null, 0)
        ,AMP_All_Flag                  {{ bigint }}  compress (null, 0)

        /* ====== Audit Fields ====== */
        ,Insert_TS                     TIMESTAMP(0)
        ,Process_Chunk                 INTEGER compress(null,0,1,2,3,4,5,6,7,8,9,10,11,12)
      )
       primary index(LogDate, Application, Statement_Bucket, Department {{ ',LogTS' if 'LogTS' in run.included else '' }} {{ ',UserName' if 'UserName' in run.included else '' }})
       on commit preserve rows



# -----------------------------------------------
# ----- Loop Logic for filling vt_dbql_core -----
# -----------------------------------------------

{% for ichunk in range(1, process_chunks+1) %}

- name: "INSERT into vt_DBQL_Core -- from DETAIL (chunk {{ ichunk }} of {{ process_chunks }})"
  connect: source
  execute:
    sql: |
      INSERT INTO vt_dbql_core -- detail
        with dbql as(
            select
             {{ dbc.logdt }} (DATE, format 'YYYY-MM-DD') as LogDate
            {% if 'LogTS' in run.included %}
            ,cast(cast(cast(starttime as format 'YYYY-MM-DDBHH') AS CHAR(13)) || ':00:00' as timestamp(0))  as LogTS
            {% endif %}
            ,AppID ,StatementType, Statements, StatementGroup
            {{ ',WDName AS Workload_Definition' if 'Workload_Definition' in run.included }}
            ,UserName, ErrorCode, Abortflag, LSN
            ,cast(HashAmp()+1 as Integer) as Total_AMPs

            /* ====== ENHANCED FIELDS ======= */
            ,((FirstStepTime - StartTime    ) HOUR(3) TO SECOND(6)) AS Parse_Time
            ,((FirstRespTime - FirstStepTime) HOUR(3) TO SECOND(6)) AS AMP_Time
            ,((FirstRespTime - StartTime    ) HOUR(3) TO SECOND(6)) AS TotalExec_Time
            ,((COALESCE(LastRespTime,FirstRespTime) - FirstRespTime) HOUR(3) TO SECOND(6)) AS Transfer_Time
            ,cast(DelayTime as {{ bigdec }}) as Delaytime_Sec
            ,ZEROIFNULL(CAST(EXTRACT(HOUR FROM Parse_Time)     * 3600 + EXTRACT(MINUTE FROM Parse_Time)     * 60 + EXTRACT(SECOND FROM Parse_Time)     AS FLOAT)) AS ParseTime_Sec
            ,ZEROIFNULL(CAST(EXTRACT(HOUR FROM AMP_Time)       * 3600 + EXTRACT(MINUTE FROM AMP_Time)       * 60 + EXTRACT(SECOND FROM AMP_Time)       AS FLOAT)) AS AMPTime_Sec
            ,ZEROIFNULL(CAST(EXTRACT(HOUR FROM TotalExec_Time) * 3600 + EXTRACT(MINUTE FROM TotalExec_Time) * 60 + EXTRACT(SECOND FROM TotalExec_Time) AS FLOAT)) AS TotalExec_Sec
            ,ZEROIFNULL(CAST(EXTRACT(HOUR FROM Transfer_Time)  * 3600 + EXTRACT(MINUTE FROM Transfer_Time)  * 60 + EXTRACT(SECOND FROM Transfer_Time)  AS FLOAT)) AS TransferTime_Sec
            ,case when TotalServerByteCount=0 then 0 else 1 end as QueryGrid_Flag
            ,case when TotalExec_Sec <= 1.00000 then 1 else 0 end as SubSecond_Flag
            ,case when d.StatementType = 'Select' and d.NumOfActiveAMPs < (Total_AMPs * 0.10) and SubSecond_Flag = 1 then 1 else 0 end  as Tactical_Flag
            ,cast(case when d.NumOfActiveAMPs = 1                                 then 1 else 0 end as byteint) as AMP_Use01_Flag
            ,cast(case when d.NumOfActiveAMPs = 2                                 then 1 else 0 end as byteint) as AMP_Use02_Flag
            ,cast(case when d.NumOfActiveAMPs <= cast(Total_AMPs /10 as smallint) then 1 else 0 end as byteint) as AMP_LT10pct_Flag
            ,cast(case when d.NumOfActiveAMPs <= cast(Total_AMPs /50 as smallint) then 1 else 0 end as byteint) as AMP_LT50pct_Flag
            ,cast(case when d.NumOfActiveAMPs = Total_AMPs                        then 1 else 0 end as byteint) as AMP_All_Flag

            {% if "Buckets" in run.included %}
            /* ====== Dimensions: Buckets ====== */
            -- encoded this way to save spool
            {% for metric in bucket_metrics %}
            {% set run.lb=0 %}
            ,cast(case when nullifzero( {{ metric.metric }} ) is NULL then 0 -- translates to: '{{ metric.format % 0 }} - {{ metric.format % 0 }}'
              {% for ub in metric.upperbounds %}
                       when {{ metric.metric }} >= {{ metric.format % run.lb }}.0  AND {{ metric.metric }} < {{ metric.format % ub }}.0  then {{ loop.index }}  -- translates to: '{{ metric.format % run.lb }} - {{ metric.format % ub }}'
                       {% set run.lb = ub %}
              {% endfor %}
                       when {{ metric.metric }} >= {{ metric.format % run.lb }}.0  then 99 -- translates to: '{{ metric.format % run.lb }}+'
                       end as byteint) as {{ metric.name }}
            {% endfor %}
            {% endif %}

            /* ====== Metrics: CPU & IO ====== */
            ,zeroifnull((cast(ParserCPUTime as {{ bigdec }}))) as CPU_Parse_Sec
            ,zeroifnull((cast(AMPCPUTime    as {{ bigdec }}))) as CPU_AMP_Sec
            ,CPU_Parse_Sec + CPU_AMP_Sec as CPU_Total_Sec
            ,case when TotalIOCount >(10**34) then 0 else TotalIOCount end as TotalIOCount_
            ,case when ReqIOKB      >(10**34) then 0 else ReqIOKB      end as ReqIOKB_
            ,case when ReqPhysIO    >(10**34) then 0 else ReqPhysIO    end as ReqPhysIO_
            ,case when ReqPhysIOKB  >(10**34) then 0 else ReqPhysIOKB  end as ReqPhysIOKB_
            ,0 as UsedIota_

            /* ====== Metrics: Other ====== */
            ,SpoolUsage, NumResultRows, NumOfActiveAMPs, NumSteps, TotalServerByteCount
            from {{ dbc.log }} as d
            {% if debug %}
            where {{ dbc.logdt }} between {{ startdate }} and {{ enddate }}
            {% else %}
            where {{ dbc.logdt }} in(Select Calendar_Date from vt_DateDriver where Process_Chunk = {{ ichunk }})
            {% endif %}
            and TotalIOCount_ < (10**34)
            and ReqIOKB_      < (10**34)
            and ReqPhysIO_    < (10**34)
            and ReqPhysIOKB_  < (10**34)

        ),

        app as (
        {% if debug %}
                Select dbql.appID
                ,case when character_length(regexp_substr(trim(dbql.appID), '^[ -~]+$', 1,1, 'i')) > 0
                      then dbql.appID else 'Invalid Character' end as AppID_Export
                ,'None'      as Pattern_Type
                ,'UnMatched' as AppID_Pattern
                ,'Unknown'   as Application
                ,'Unknown'   as Application_Company
                ,'Unknown'   as Application_Use
                ,1 as Priority
                ,'Customer'  as Data_Source
                from (  select AppID
                        from {{ dbc.log }}
                        where {{ dbc.logdt }} between {{ startdate | default('DATE-91') }} and {{ enddate | default('DATE-1') }}
                        group by 1
                    ) as dbql
        {% else %}
                Select AppID, AppID_Export, Pattern_Type, AppID_Pattern
                ,Application, Usage as Application_Use, Company as Application_Company
                from vt_decode_appid
        {% endif %}
        ),

        stm as (
        {% if debug %}
                Select '' as Statement_Type, '' as Statement_Class, '' as Statement_Bucket, '' as Statement_Outcome
                from (Select 1 as One) a where One=2
        {% else %}
                Select s.*
                from vt_decode_statement as s
        {% endif %}
        ),

        usr as (
        {% if debug %}
                Select DatabaseName as UserName2
                ,'Unknown' as FullName
                ,'Unknown' as UserType
                ,'Unknown' as Organization
                ,'Unknown' as Department
                ,0 as Exclude_VantageUnit_Flag
                ,0 as Exclude_Performance_Flag
                from dbc.DatabasesV
                where DBKind = 'U'
        {% else %}
                Select UserName as UserName2, FullName, UserType, Organization, Department
                ,Exclude_VantageUnit_Flag, Exclude_Performance_Flag
                from vt_decode_user as u
        {% endif %}
        )
        ------------------------------------
        ------------------------------------
        Select
        '{{ siteid }}' as Site_ID
        ,LogDate
        {{ ',LogTS' if 'LogTS' in run.included }}
        /* ====== Dimensions: Usage ======= */
        ,Application
        ,Application_Use
        ,Application_Company
        ,Statement_Bucket
        ,Statement_Outcome
        {{ ',Workload_Definition' if 'Workload_Definition' in run.included }}
        {{ ',UserName'            if 'UserName'            in run.included }}
        ,UserType
        ,Organization
        ,Department

        /* ====== Dimensions: Flags ======= */
        {{ ',QueryGrid_Flag'                 if 'QueryGrid_Flag' in run.included }}
        {{ ',SubSecond_Flag'                 if 'SubSecond_Flag' in run.included }}
        {{ ',Tactical_Flag'                  if 'Tactical_Flag'  in run.included }}
        {{ ',usr.Exclude_Performance_Flag'   if 'Exclude_Flag'  in run.included }}
        {{ ',usr.Exclude_VantageUnit_Flag'   if 'Exclude_Flag'  in run.included }}

        {% if "Buckets" in run.included %}
        /* ====== Dimensions: Buckets ====== */
        {% for metric in bucket_metrics %}
        {% set run.lb=0 %}
        ,case   when {{ metric.name }} = 0 then '{{ metric.format % 0 }} - {{ metric.format % 0 }}'
          {% for ub in metric.upperbounds %}
                when {{ metric.name }} = {{ loop.index }} then '{{ metric.format % run.lb }} - {{ metric.format % ub }}'
                {% set run.lb = ub %}
          {% endfor %}
                when {{ metric.name }} = 99  then '{{ metric.format % run.lb }}+'
                end as {{ metric.name }}
        {% endfor %}
        {% endif %}

        /* ====== Request and Statement Counts ======= */
        ,zeroifnull(cast(count(*) as {{ bigint }})) as Request_Total_Cnt
        ,zeroifnull(sum(cast(dbql.Statements as {{ bigint }}))) as Statement_Total_Cnt
        ,zeroifnull(sum(cast(case when dbql.StatementGroup like '%=%'       then 1               else 0 end as {{ bigint }}))) as Request_MultiStatement_Cnt
        ,zeroifnull(sum(cast(case when dbql.SubSecond_Flag = 1              then 1               else 0 end as {{ bigint }}))) as   Request_SubSecond_Cnt
        ,zeroifnull(sum(cast(case when dbql.SubSecond_Flag = 1              then dbql.Statements else 0 end as {{ bigint }}))) as Statement_SubSecond_Cnt
        ,zeroifnull(sum(cast(case when dbql.Tactical_Flag = 1               then 1               else 0 end as {{ bigint }}))) as   Request_Tactical_Cnt
        ,zeroifnull(sum(cast(case when dbql.Tactical_Flag = 1               then dbql.Statements else 0 end as {{ bigint }}))) as Statement_Tactical_Cnt
        ,zeroifnull(sum(cast(case when dbql.ErrorCode not     in(0,3158)    then 1               else 0 end as {{ bigint }}))) as   Request_Error_Cnt
        ,zeroifnull(sum(cast(case when dbql.ErrorCode not     in(0,3158)    then dbql.Statements else 0 end as {{ bigint }}))) as Statement_Error_Cnt
        ,zeroifnull(sum(cast(case when dbql.ErrorCode         in(2646)      then 1               else 0 end as {{ bigint }}))) as   Request_Spool_Error_Cnt
        ,zeroifnull(sum(cast(case when dbql.ErrorCode         in(2646)      then dbql.Statements else 0 end as {{ bigint }}))) as Statement_Spool_Error_Cnt
        ,zeroifnull(sum(cast(case when dbql.ErrorCode         in(3158)      then 1               else 0 end as {{ bigint }}))) as   Request_TASM_Abort_Cnt
        ,zeroifnull(sum(cast(case when dbql.ErrorCode         in(3158)      then dbql.Statements else 0 end as {{ bigint }}))) as Statement_TASM_Abort_Cnt
        ,zeroifnull(sum(cast(case when dbql.Abortflag = 'T'                 then 1               else 0 end as {{ bigint }}))) as   Request_Abort_Cnt
        ,zeroifnull(sum(cast(case when dbql.Abortflag = 'T'                 then dbql.Statements else 0 end as {{ bigint }}))) as Statement_Abort_Cnt
        ,zeroifnull(sum(cast(case when TotalIOCount_ = 0                    then 1               else 0 end as {{ bigint }}))) as   Request_NoIO_Cnt
        ,zeroifnull(sum(cast(case when TotalIOCount_ = 0                    then dbql.Statements else 0 end as {{ bigint }}))) as Statement_NoIO_Cnt
        ,zeroifnull(sum(cast(case when TotalIOCount_ > 0 AND ReqPhysIO_ = 0 then 1               else 0 end as {{ bigint }}))) as   Request_InMem_Cnt
        ,zeroifnull(sum(cast(case when TotalIOCount_ > 0 AND ReqPhysIO_ = 0 then dbql.Statements else 0 end as {{ bigint }}))) as Statement_InMem_Cnt
        ,zeroifnull(sum(cast(case when TotalIOCount_ > 0 AND ReqPhysIO_ > 0 then 1               else 0 end as {{ bigint }}))) as   Request_PhysIO_Cnt
        ,zeroifnull(sum(cast(case when TotalIOCount_ > 0 AND ReqPhysIO_ > 0 then dbql.Statements else 0 end as {{ bigint }}))) as Statement_PhysIO_Cnt
        ,zeroifnull(sum(cast(case when numofactiveamps = hashamp()+1        then 1               else 0 end as {{ bigint }}))) as   Request_AllAMP_Cnt
        ,zeroifnull(sum(cast(case when numofactiveamps = hashamp()+1        then dbql.Statements else 0 end as {{ bigint }}))) as Statement_AllAMP_Cnt
        ,zeroifnull(sum(cast(case when (LSN is not null or LSN >0)          then 1               else 0 end as {{ bigint }}))) as   Request_Utility_Cnt
        ,zeroifnull(sum(cast(case when (LSN is not null or LSN >0)          then dbql.Statements else 0 end as {{ bigint }}))) as Statement_Utility_Cnt
        ,zeroifnull(sum(cast( QueryGrid_Flag                                                                as {{ bigint }}))) as    Request_QueryGrid_Cnt
        ,zeroifnull(sum(cast( case when QueryGrid_Flag = 1                  then Statements      else 0 end as {{ bigint }}))) as  Statement_QueryGrid_Cnt

        /* ====== Metrics: RunTimes ====== */
        ,sum(cast(DelayTime_Sec           as {{ bigdec }})) as DelayTime_Sec
        ,sum(cast(ParseTime_Sec           as {{ bigdec }})) as RunTime_Parse_Sec
        ,sum(cast(AMPTime_Sec             as {{ bigdec }})) as Runtime_AMP_Sec
        ,sum(cast(TotalExec_Sec           as {{ bigdec }})) as RunTime_Total_Sec
        ,sum(cast(TransferTime_Sec        as {{ bigdec }})) as TransferTime_Sec

        /* ====== Metrics: CPU & IO ====== */
        ,sum(cast(CPU_Total_Sec           as {{ bigdec }})) as CPU_Total_Sec
        ,sum(cast(CPU_AMP_Sec             as {{ bigdec }})) as CPU_AMP_Sec
        ,sum(cast(TotalIOCount_ / 1e6     as {{ bigdec }})) as IO_Total_CntM
        ,sum(cast(ReqPhysIO_    / 1e6     as {{ bigdec }})) as IO_Physical_CntM
        ,sum(cast(ReqIOKB_      / 1e6     as {{ bigdec }})) as IO_Total_GB
        ,sum(cast(ReqPhysIOKB_  / 1e6     as {{ bigdec }})) as IO_Physical_GB
        ,sum(cast(UsedIota_     / 1e9     as {{ bigdec }})) as IOTA_Used_CntB

        /* ====== Metrics: Other ====== */
        ,sum(cast(SpoolUsage /1e9                as {{ bigdec }}))     as Spool_GB
        ,sum(cast(NumResultRows                  as {{ bigdec }}))     as Returned_Row_Cnt
        ,cast(avg(NumOfActiveAMPs (float)      ) as {{ bigdec }}) as NumOfActiveAMPs_Avg
        ,cast(sum(TotalServerByteCount (float) ) as {{ bigdec }}) as QueryGrid_Bytes
        ,cast(zeroifnull(cast(sum(ReqPhysIO_)   as float) / nullifzero(cast(nullifzero(sum(TotalIOCount_)) as float))) as {{ bigdec }}) as CacheMiss_CntPct
        ,cast(zeroifnull(cast(sum(ReqPhysIOKB_) as float) / nullifzero(cast(nullifzero(sum(ReqIOKB_))      as float))) as {{ bigdec }}) as CacheMiss_SizePct
        ,cast(case
         when CacheMiss_CntPct <= 0.20 then 0                   /* set score = 0 when less than industry average 20% */
         when CacheMiss_CntPct >= 1.00 then 10                  /* sometimes get Physical > Logical, set to ceiling */
         else cast((CacheMiss_CntPct - 0.20) * 12.5 as integer) /* scale spread of .80 (0.20 to 1.00) to a spread of 10 (1 to 10) */
          end as {{ bigdec }}) as CacheMiss_CntScore
        ,cast(case
         when CacheMiss_SizePct <= 0.20 then 0                   /* set score = 0 when less than industry average 20% */
         when CacheMiss_SizePct >= 1.00 then 10                  /* sometimes get Physical > Logical, set to ceiling */
         else cast((CacheMiss_SizePct - 0.20) * 12.5 as integer) /* scale spread of .80 (0.20 to 1.00) to a spread of 10 (1 to 10) */
          end as {{ bigdec }}) as CacheMiss_SizeScore
        ,Total_AMPs
        ,zeroifnull(sum(cast(AMP_Use01_Flag   as {{ bigint }})))  as AMP_Use01_Flag
        ,zeroifnull(sum(cast(AMP_Use02_Flag   as {{ bigint }}))) as AMP_Use02_Flag
        ,zeroifnull(sum(cast(AMP_LT10pct_Flag as {{ bigint }}))) as AMP_LT10pct_Flag
        ,zeroifnull(sum(cast(AMP_LT50pct_Flag as {{ bigint }}))) as AMP_LT50pct_Flag
        ,zeroifnull(sum(cast(AMP_All_Flag     as {{ bigint }}))) as AMP_All_Flag

        /* ====== Audit Fields ====== */
        ,current_Timestamp(0) as Insert_TS
        ,{{ ichunk }} as Process_Chunk

        from dbql
        join usr             on dbql.UserName = usr.UserName2            --<=== VT is complete 1:1 mapping, Equal Join OK
        join app             on app.AppID = dbql.AppID                   --<=== VT is complete 1:1 mapping, Equal Join OK
        left outer join stm  on dbql.StatementType = stm.Statement_Type  --<=== may be incomplete, Outer Join required

        group by
         LogDate
        {{ ',LogTS' if 'LogTS' in run.included }}
        /* ====== Dimensions: Usage ======= */
        ,Application
        ,Application_Use
        ,Application_Company
        ,Statement_Bucket
        ,Statement_Outcome
        {{ ',Workload_Definition' if 'Workload_Definition' in run.included }}
        {{ ',UserName'            if 'UserName'            in run.included }}
        ,UserType
        ,Organization
        ,Department

        /* ====== Dimensions: Flags ======= */
        {{ ',QueryGrid_Flag'                 if 'QueryGrid_Flag' in run.included }}
        {{ ',SubSecond_Flag'                 if 'SubSecond_Flag' in run.included }}
        {{ ',Tactical_Flag'                  if 'Tactical_Flag'  in run.included }}
        {{ ',usr.Exclude_Performance_Flag'   if 'Exclude_Flag'  in run.included }}
        {{ ',usr.Exclude_VantageUnit_Flag'   if 'Exclude_Flag'  in run.included }}

        {% if "Buckets" in run.included %}
        /* ====== Dimensions: Buckets ====== */
        {% for metric in bucket_metrics %}
        ,{{ metric.name }}
        {% endfor %}
        {% endif %}



- name: "INSERT into vt_DBQL_Core -- from SUMMARY (chunk {{ ichunk }} of {{ process_chunks }})"
  connect: source
  execute:
    sql: |
      INSERT INTO vt_dbql_core -- summary
        with dbql as(
            Select
             cast(CollectTimeStamp as date) as LogDate
             {% if 'LogTS' in run.included %}
             ,cast(cast(cast(CollectTimeStamp as format 'YYYY-MM-DDBHH') AS CHAR(13)) || ':00:00' as timestamp(0))  as LogTS
             {% endif %}
            ,AppID, QueryCount as Statements, {{ "'Summary Queries'" if td15 else "UserName" }} as UserName, 0 as ErrorCode, '' as Abortflag, 0 as LSN

            /* ====== ENHANCED FIELDS ======= */
            ,cast(HashAmp()+1 as Integer) as Total_AMPs
            ,cast(null as interval HOUR(3) TO SECOND(6)) as Parse_Time
            ,cast(null as interval HOUR(3) TO SECOND(6)) as AMP_Time
            ,cast(null as interval HOUR(3) TO SECOND(6)) as TotalExec_Time
            ,cast(null as interval HOUR(3) TO SECOND(6)) as Transfer_Time
            ,0 as Delaytime_Sec
            ,0 as ParseTime_Sec
            ,0 as AMPTime_Sec
            ,zeroifnull(cast(smry.QuerySeconds as {{ bigdec }})) as TotalExec_Sec
            ,0 as TransferTime_Sec
            ,0 as QueryGrid_Flag
            ,zeroifnull(case when (cast(TotalExec_Sec as float) / nullifzero(cast(QueryCount as float))) <= 1.00000 then 1 else 0 end) as SubSecond_Flag
            ,SubSecond_Flag as Tactical_Flag

            /* ====== Metrics: CPU & IO ====== */
            ,zeroifnull((cast(ParserCPUTime as {{ bigdec }}))) as CPU_Parse_Sec
            ,zeroifnull((cast(AMPCPUTime    as {{ bigdec }}))) as CPU_AMP_Sec
            ,CPU_Parse_Sec + CPU_AMP_Sec as CPU_Total_Sec
            ,case when TotalIOCount     >(10**34) then 0 else TotalIOCount end as TotalIOCount_
            {% if td15 %}
            ,0 as ReqPhysIO_
            ,0 as ReqIOKB_
            ,0 as ReqPhysIOKB_
            {% else %}
            ,cast(case when ReqPhysIO   >(10**34) then 0 else ReqPhysIO   end as {{ bigdec }}) as ReqPhysIO_
            ,cast(0                                                           as {{ bigint }}) as ReqIOKB_
            ,cast(case when ReqPhysIOKB >(10**34) then 0 else ReqPhysIOKB end as {{ bigdec }}) as ReqPhysIOKB_
            {% endif %}
            ,0 as UsedIota_

            /* ====== Metrics: Other ====== */
            ,0 SpoolUsage, 0 NumResultRows, 0 NumOfActiveAMPs, 0 NumSteps, 0 TotalServerByteCount
            From {{ dbc.summary }} smry
            {% if debug %}
            where {{ dbc.logdt }} between {{ startdate }} and {{ enddate }}
            {% else %}
            where {{ dbc.logdt }} in(Select Calendar_Date from vt_DateDriver where Process_Chunk = {{ ichunk }})
            {% endif %}
            and TotalIOCount_ < (10**34)
            and ReqIOKB_      < (10**34)
            and ReqPhysIO_    < (10**34)
            and ReqPhysIOKB_  < (10**34)

        ),

        app as (
        {% if debug %}
                Select dbql.appID
                ,case when character_length(regexp_substr(trim(dbql.appID), '^[ -~]+$', 1,1, 'i')) > 0
                      then dbql.appID else 'Invalid Character' end as AppID_Export
                ,'None'      as Pattern_Type
                ,'UnMatched' as AppID_Pattern
                ,'Unknown'   as Application
                ,'Unknown'   as Application_Company
                ,'Unknown'   as Application_Use
                ,cast(((select trunc(date, 'MONTH')-1))-((select trunc(date-28, 'MONTH'))) +1 as INT)  as DayCount
                ,1 as Priority
                ,'Customer'  as Data_Source
                from (  select AppID
                        from {{ dbc.log }}
                        where {{ dbc.logdt }} between {{ startdate | default('DATE-91') }} and {{ enddate | default('DATE-1') }}
                        group by 1
                    ) as dbql
        {% else %}
                Select AppID, AppID_Export, Pattern_Type, AppID_Pattern
                ,Application, Usage as Application_Use, Company as Application_Company
                from vt_decode_appid
        {% endif %}
        ),

        usr as (
        {% if debug %}
                Select DatabaseName as UserName2
                ,'Unknown' as FullName
                ,'Unknown' as UserType
                ,'Unknown' as Organization
                ,'Unknown' as Department
                ,0 as Exclude_VantageUnit_Flag
                ,0 as Exclude_Performance_Flag
                from dbc.DatabasesV
                where DBKind = 'U'
        {% else %}
                Select UserName as UserName2, FullName, UserType, Organization, Department
                ,Exclude_VantageUnit_Flag, Exclude_Performance_Flag
                from vt_decode_user as u
        {% endif %}
        )
        ------------------------------------
        ------------------------------------
        Select
        '{{ siteid }}' as Site_ID
        ,LogDate
        {{ ',LogTS' if 'LogTS' in run.included }}
        /* ====== Dimensions: Usage ======= */
        ,Application
        ,Application_Use
        ,Application_Company
        ,'Summary Queries' as Statement_Bucket
        ,'Summary Queries' as Statement_Outcome
        {{ ",'Summary Queries' as Workload_Definition" if 'Workload_Definition' in run.included }}
        {{ ",UserName"  if 'UserName' in run.included }}
        ,UserType
        ,Organization
        ,Department

        /* ====== Dimensions: Flags ======= */
        {{ ',QueryGrid_Flag'                 if 'QueryGrid_Flag' in run.included }}
        {{ ',SubSecond_Flag'                 if 'SubSecond_Flag' in run.included }}
        {{ ',Tactical_Flag'                  if 'Tactical_Flag'  in run.included }}
        {{ ',usr.Exclude_Performance_Flag'   if 'Exclude_Flag'  in run.included }}
        {{ ',usr.Exclude_VantageUnit_Flag'   if 'Exclude_Flag'  in run.included }}

        {% if "Buckets" in run.included %}
        /* ====== Dimensions: Buckets ====== */
        ,'Summary Queries' as Delaytime_Bucket
        ,'Summary Queries' as ParseTime_Bucket
        ,'Summary Queries' as AMPTime_Bucket
        ,'Summary Queries' as TotalExec_Bucket
        ,'Summary Queries' as TransferTime_Bucket
        ,'Summary Queries' as CPU_Parse_Bucket
        ,'Summary Queries' as CPU_AMP_Bucket
        ,'Summary Queries' as TotalIOC_Bucket
        {% endif %}

        /* ====== Request and Statement Counts ======= */
        ,zeroifnull(cast(count(*) as {{ bigint }})) as Request_Total_Cnt
        ,zeroifnull(sum(cast(dbql.Statements as {{ bigint }}))) as Statement_Total_Cnt
        ,0 as Request_MultiStatement_Cnt
        ,zeroifnull(sum(cast(case when dbql.SubSecond_Flag = 1              then 1               else 0 end as {{ bigint }}))) as   Request_SubSecond_Cnt
        ,zeroifnull(sum(cast(case when dbql.SubSecond_Flag = 1              then dbql.Statements else 0 end as {{ bigint }}))) as Statement_SubSecond_Cnt
        ,zeroifnull(sum(cast(case when dbql.Tactical_Flag = 1               then 1               else 0 end as {{ bigint }}))) as   Request_Tactical_Cnt
        ,zeroifnull(sum(cast(case when dbql.Tactical_Flag = 1               then dbql.Statements else 0 end as {{ bigint }}))) as Statement_Tactical_Cnt
        ,zeroifnull(sum(cast(case when dbql.ErrorCode not     in(0,3158)    then 1               else 0 end as {{ bigint }}))) as   Request_Error_Cnt
        ,zeroifnull(sum(cast(case when dbql.ErrorCode not     in(0,3158)    then dbql.Statements else 0 end as {{ bigint }}))) as Statement_Error_Cnt
        ,zeroifnull(sum(cast(case when dbql.ErrorCode         in(2646)      then 1               else 0 end as {{ bigint }}))) as   Request_Spool_Error_Cnt
        ,zeroifnull(sum(cast(case when dbql.ErrorCode         in(2646)      then dbql.Statements else 0 end as {{ bigint }}))) as Statement_Spool_Error_Cnt
        ,zeroifnull(sum(cast(case when dbql.ErrorCode         in(3158)      then 1               else 0 end as {{ bigint }}))) as   Request_TASM_Abort_Cnt
        ,zeroifnull(sum(cast(case when dbql.ErrorCode         in(3158)      then dbql.Statements else 0 end as {{ bigint }}))) as Statement_TASM_Abort_Cnt
        ,zeroifnull(sum(cast(case when dbql.Abortflag = 'T'                 then 1               else 0 end as {{ bigint }}))) as   Request_Abort_Cnt
        ,zeroifnull(sum(cast(case when dbql.Abortflag = 'T'                 then dbql.Statements else 0 end as {{ bigint }}))) as Statement_Abort_Cnt
        ,zeroifnull(sum(cast(case when TotalIOCount_ = 0                    then 1               else 0 end as {{ bigint }}))) as   Request_NoIO_Cnt
        ,zeroifnull(sum(cast(case when TotalIOCount_ = 0                    then dbql.Statements else 0 end as {{ bigint }}))) as Statement_NoIO_Cnt
        ,zeroifnull(sum(cast(case when TotalIOCount_ > 0 AND ReqPhysIO_ = 0 then 1               else 0 end as {{ bigint }}))) as   Request_InMem_Cnt
        ,zeroifnull(sum(cast(case when TotalIOCount_ > 0 AND ReqPhysIO_ = 0 then dbql.Statements else 0 end as {{ bigint }}))) as Statement_InMem_Cnt
        ,zeroifnull(sum(cast(case when TotalIOCount_ > 0 AND ReqPhysIO_ > 0 then 1               else 0 end as {{ bigint }}))) as   Request_PhysIO_Cnt
        ,zeroifnull(sum(cast(case when TotalIOCount_ > 0 AND ReqPhysIO_ > 0 then dbql.Statements else 0 end as {{ bigint }}))) as Statement_PhysIO_Cnt
        ,zeroifnull(sum(cast(case when numofactiveamps = hashamp()+1        then 1               else 0 end as {{ bigint }}))) as   Request_AllAMP_Cnt
        ,zeroifnull(sum(cast(case when numofactiveamps = hashamp()+1        then dbql.Statements else 0 end as {{ bigint }}))) as Statement_AllAMP_Cnt
        ,zeroifnull(sum(cast(case when (LSN is not null or LSN >0)          then 1               else 0 end as {{ bigint }}))) as   Request_Utility_Cnt
        ,zeroifnull(sum(cast(case when (LSN is not null or LSN >0)          then dbql.Statements else 0 end as {{ bigint }}))) as Statement_Utility_Cnt
        ,zeroifnull(sum(cast( QueryGrid_Flag                                                                as {{ bigint }}))) as    Request_QueryGrid_Cnt
        ,zeroifnull(sum(cast( case when QueryGrid_Flag = 1                  then Statements      else 0 end as {{ bigint }}))) as  Statement_QueryGrid_Cnt

        /* ====== Metrics: RunTimes ====== */
        ,sum(cast(DelayTime_Sec             as {{ bigdec }})) as DelayTime_Sec
        ,sum(cast(ParseTime_Sec             as {{ bigdec }})) as RunTime_Parse_Sec
        ,sum(cast(AMPTime_Sec               as {{ bigdec }})) as Runtime_AMP_Sec
        ,sum(cast(TotalExec_Sec             as {{ bigdec }})) as RunTime_Total_Sec
        ,sum(cast(TransferTime_Sec          as {{ bigdec }})) as TransferTime_Sec

        /* ====== Metrics: CPU & IO ====== */
        ,sum(cast(CPU_Total_Sec             as {{ bigdec }})) as CPU_Total_Sec
        ,sum(cast(CPU_AMP_Sec               as {{ bigdec }})) as CPU_AMP_Sec
        ,sum(cast(TotalIOCount_ / 1e6       as {{ bigdec }})) as IO_Total_CntM
        ,sum(cast(ReqPhysIO_    / 1e6       as {{ bigdec }})) as IO_Physical_CntM
        ,sum(cast(ReqIOKB_      / 1e6       as {{ bigdec }})) as IO_Total_GB
        ,sum(cast(ReqPhysIOKB_  / 1e6       as {{ bigdec }})) as IO_Physical_GB
        ,sum(cast(UsedIota_     / 1e9       as {{ bigdec }})) as IOTA_Used_CntB

        /* ====== Metrics: Other ====== */
        ,sum(cast(SpoolUsage /1e9                as {{ bigdec }}))     as Spool_GB
        ,sum(cast(NumResultRows                  as {{ bigdec }}))     as Returned_Row_Cnt
        ,cast(avg(NumOfActiveAMPs (float)      ) as {{ bigdec }}) as NumOfActiveAMPs_Avg
        ,cast(sum(TotalServerByteCount (float) ) as {{ bigdec }}) as QueryGrid_Bytes
        ,cast(zeroifnull(cast(sum(ReqPhysIO_)   as float) / nullifzero(cast(nullifzero(sum(TotalIOCount_)) as float))) as {{ bigdec }}) as CacheMiss_CntPct
        ,cast(zeroifnull(cast(sum(ReqPhysIOKB_) as float) / nullifzero(cast(nullifzero(sum(ReqIOKB_))      as float))) as {{ bigdec }}) as CacheMiss_SizePct
        ,cast(case
         when CacheMiss_CntPct <= 0.20 then 0                   /* set score = 0 when less than industry average 20% */
         when CacheMiss_CntPct >= 1.00 then 10                  /* sometimes get Physical > Logical, set to ceiling */
         else cast((CacheMiss_CntPct - 0.20) * 12.5 as integer) /* scale spread of .80 (0.20 to 1.00) to a spread of 10 (1 to 10) */
          end as {{ bigdec }}) as CacheMiss_CntScore
        ,cast(case
         when CacheMiss_SizePct <= 0.20 then 0                   /* set score = 0 when less than industry average 20% */
         when CacheMiss_SizePct >= 1.00 then 10                  /* sometimes get Physical > Logical, set to ceiling */
         else cast((CacheMiss_SizePct - 0.20) * 12.5 as integer) /* scale spread of .80 (0.20 to 1.00) to a spread of 10 (1 to 10) */
          end as {{ bigdec }}) as CacheMiss_SizeScore
        ,Total_AMPs
        ,0 as AMP_Use01_Flag
        ,0 as AMP_Use02_Flag
        ,0 as AMP_LT10pct_Flag
        ,0 as AMP_LT50pct_Flag
        ,0 as AMP_All_Flag

        /* ====== Audit Fields ====== */
        ,current_Timestamp(0) as Insert_TS
        ,{{ ichunk }} as Process_Chunk

        from dbql
        join usr             on dbql.UserName = usr.UserName2            --<=== VT is complete 1:1 mapping, Equal Join OK
        join app             on app.AppID = dbql.AppID                   --<=== VT is complete 1:1 mapping, Equal Join OK

        group by
         LogDate
        {{ ',LogTS' if 'LogTS' in run.included }}
        /* ====== Dimensions: Usage ======= */
        ,Application
        ,Application_Use
        ,Application_Company
        {{ ',UserName'            if 'UserName'            in run.included }}
        ,UserType
        ,Organization
        ,Department

        /* ====== Dimensions: Flags ======= */
        {{ ',QueryGrid_Flag'                 if 'QueryGrid_Flag' in run.included }}
        {{ ',SubSecond_Flag'                 if 'SubSecond_Flag' in run.included }}
        {{ ',Tactical_Flag'                  if 'Tactical_Flag'  in run.included }}
        {{ ',usr.Exclude_Performance_Flag'   if 'Exclude_Flag'  in run.included }}
        {{ ',usr.Exclude_VantageUnit_Flag'   if 'Exclude_Flag'  in run.included }}

{% endfor %}



- name: "Collect Stats on vt_dbql_core"
  connect: source
  execute:
    sql: |
      collect stats
         column (LogDate, Application, Statement_Bucket, Department {{ ',LogTS' if 'LogTS' in run.included else '' }} {{ ',UserName' if 'UserName' in run.included else '' }})
        ,column (LogDate)
        ,column (Application)
        ,column (Statement_Bucket)
        ,column (Department)
      on vt_dbql_core



#  RECONCILE
# =================================================================
{% if reconcile %}

- name: "Create RECONCILE Process: vt_dbql_core_reconcile"
  connect: source
  execute:
    sql: |
      Create volatile table vt_dbql_core_reconcile
      (Row_Order      integer
      ,Source_Name    varchar(128)
      ,LogDate_Count  integer
      ,CPU_Sec        decimal(36,3)
      ,Row_Count      bigint)
      no primary index
      on commit preserve rows

- name: "RECONCILE: RAW {{ dbc.log }}"
  connect: source
  execute:
    sql: |
      insert into vt_dbql_core_reconcile
      Select 1 as Row_Order
      ,'RAW {{ dbc.log }}' as Source_Name
      ,count(distinct {{ dbc.logdt }} ) as LogDate_Count
      ,zeroifnull(sum(AMPCPUtime+ParserCPUTime)(decimal(36,3))) as CPU_AMP_Sec
      ,count(*) as row_count
      from {{ dbc.log }}
      where {{ dbc.logdt }} between {{ startdate | default('DATE-91') }} and {{ enddate | default('DATE-1') }}

- name: "RECONCILE: RAW {{ dbc.summary }}"
  connect: source
  execute:
    sql: |
      insert into vt_dbql_core_reconcile
      Select 2 as Row_Order
      ,'RAW {{ dbc.summary }}' as Source_Name
      ,count(distinct cast({{ 'CollectTimeStamp' if td15 else 'starttime' }} as date) ) as LogDate_Count
      ,zeroifnull(sum(AMPCPUtime+ParserCPUTime)(decimal(36,3))) as CPU_AMP_Sec
      ,count(*) as row_count
      from {{ dbc.summary }}
      where cast({{ 'CollectTimeStamp' if td15 else 'starttime' }} as date) between {{ startdate | default('DATE-91') }} and {{ enddate | default('DATE-1') }}

- name: "RECONCILE: DBQLogTbl + DBQLSummary"
  connect: source
  execute:
    sql: |
      insert into vt_dbql_core_reconcile
      select 3, 'DBQLogTbl + DBQLSummary'
      ,max(LogDate_Count), sum(CPU_Sec), sum(Row_Count)
      from vt_dbql_core_reconcile
      where Row_Order in(1,2)

- name: "RECONCILE: vt_dbql_core"
  connect: source
  execute:
    sql: |
      insert into vt_dbql_core_reconcile
      Select 4 as Row_Order
      ,'vt_dbql_core' as Source_Name
      ,count(distinct LogDate ) as LogDate_Count
      ,sum(CPU_Total_Sec)(decimal(18,3)) as CPU_AMP_Sec
      ,count(*) as row_count
      from vt_dbql_core

- name: "RECONCILE: Export final records"
  connect: source
  export:
    file: reconcile_DBQL_Core.csv
    sql: Select * from vt_dbql_core_reconcile order by Row_Order

- name: "Drop vt_dbql_core_reconcile"
  connect: source
  execute:
    sql: drop table vt_dbql_core_reconcile

{% endif %}


{% endif %}
{{ run.completed.append('vt_dbql_core') or '' }}
