{% set run = namespace(completed=[]) if run is not defined else run %}
{% if not 'vt_dbql_core' in run.completed %}


### ============= SET DEFAULT EXECUTION BEHAVIOR =============
{% set td15           = true  if tdver[:2]=='15'                else false %}
{% set reconcile      = false if reconcile       is not defined else reconcile %}
{% set save_prework   = false if save_prework    is not defined else save_prework %}
{% set process_chunks = 1     if process_chunks  is not defined else process_chunks %}
{% set run.buckets    = false %}  # set to True in the "build dimension" below, if appropriate


### ============= BUILD Included Flag List =============
# this macro will combine "include" and all include_* variables
# into a single "included" variable list for easy testing in SQL
{% import "coa_util.j2" as macro with context %}
{{ macro.build_include_flags(run, ['Default']) }}

# let's output all inclusions, just for reconciliation:
- name: Export all included dimensions, just for reference
  connect: source
  export:
    file: reconcile_dbql_core_settings.csv
    sql: |
      {% for incl in run.included %}
      select * from (select '{{ incl }}'(VARCHAR(128)) as Variable) a{{ loop.index }}
      {% if not loop.last %}
        union all
      {% endif %}
      {% endfor %}



# =================================================================
#     load dimensional table mappings:
{% include "vt_datedriver.j2" %}
{% include "vt_decode_appid.j2" %}
{% include "vt_decode_user.j2" %}
{% include "vt_decode_statement.j2" %}
# =================================================================

# Define Bucket Logic:
{% set bucket_metrics = [ {"metric":"Delaytime_Sec",    "name":"Delaytime_Bucket   ", "format":"%04d", "upperbounds":[1,5,10,30,60,300,600,1800,3600] },
                          {"metric":"ParseTime_Sec",    "name":"ParseTime_Bucket   ", "format":"%04d", "upperbounds":[1,5,10,30,60,300,600,1800,3600] },
                          {"metric":"AMPTime_Sec",      "name":"AMPTime_Bucket     ", "format":"%04d", "upperbounds":[1,5,10,30,60,300,600,1800,3600] },
                          {"metric":"TotalExec_Sec",    "name":"TotalExec_Bucket   ", "format":"%04d", "upperbounds":[1,5,10,30,60,300,600,1800,3600] },
                          {"metric":"TransferTime_Sec", "name":"TransferTime_Bucket", "format":"%04d", "upperbounds":[1,5,10,30,60,300,600,1800,3600] },
                          {"metric":"CPU_Total_Sec",    "name":"CPU_Total_Bucket   ", "format":"%06d", "upperbounds":[1,10,100,1000,10000,100000] },
                          {"metric":"CPU_AMP_Sec",      "name":"CPU_AMP_Bucket     ", "format":"%06d", "upperbounds":[1,10,100,1000,10000,100000] },
                          {"metric":"TotalIOCount_",    "name":"IOCnt_Total_Bucket ", "format":"%07d", "upperbounds":[1,10,100,1000,10000,100000,1000000] },] %}


- name: "Create table: vt_dbql_core (td15 = {{td15}})"
  connect: source
  execute:
    sql: |
      create volatile table vt_dbql_core (
         Site_ID                       VARCHAR(128)
        ,LogDate                       DATE format 'yyyy-mm-dd'
        {% if 'LogTS' in run.included %}
        ,LogTS                         TIMESTAMP(0)
        {% endif %}

        /* ====== Dimensions: Usage ======= */
        ,Application                   VARCHAR(128)
        ,Application_Use               VARCHAR(128)
        ,Application_Company           VARCHAR(128)
        ,Statement_Bucket              VARCHAR(128)
        ,Statement_Outcome             VARCHAR(128)
        {{ ',Workload_Definition           VARCHAR(128) compress (null)' if 'Workload_Definition' in run.included }}
        {{ ',UserName                      VARCHAR(128)' if 'UserName' in run.included }}
        ,UserType                      VARCHAR(128)
        ,Organization                  VARCHAR(128)
        ,Department                    VARCHAR(128)

        /* ====== Dimensions: Flags (optional) ======= */
        {{ ',SubSecond_Flag                BYTEINT compress (null,0,1)' if 'SubSecond_Flag'  in run.included }}
        {{ ',Tactical_Flag                 BYTEINT compress (null,0,1)' if 'Tactical_Flag'   in run.included }}
        {{ ',QueryGrid_Flag                BYTEINT compress (null,0,1)' if 'QueryGrid_Flag'  in run.included }}
        {{ ',Exclude_Performance_Flag      BYTEINT compress (null,0,1)' if 'Exclude_Flag'   in run.included }}
        {{ ',Exclude_VantageUnit_Flag      BYTEINT compress (null,0,1)' if 'Exclude_Flag'   in run.included }}

      {% if "Buckets" in run.included %}
        /* ====== Dimensions: Buckets ====== */
        {%- for metric in bucket_metrics -%}
          {% set run.lb=0 -%}
          {% set compress = ['null', "'" ~ metric.format % 0 ~ " - " ~ metric.format % 0 ~ "'" ] -%}
          {% for ub in metric.upperbounds -%}
          {{ compress.append("'" ~ metric.format %  run.lb ~ " - " ~ metric.format % ub ~ "'" )  or '' }}
          {%- set run.lb = ub -%}
        {% endfor -%}
        {{ compress.append("'" ~ metric.format %  run.lb ~ "+'")  or '' }}
        ,{{ metric.name }}           VARCHAR(32) compress( {{ compress | join(',') }} ){% endfor %}
      {% endif %}


        /* ====== Request and Statement Counts ======= */
        ,  Request_Total_Cnt           BIGINT compress (null, 0)
        ,Statement_Total_Cnt           BIGINT compress (null, 0)
        ,  Request_MultiStatement_Cnt  BIGINT compress (null, 0)
        ,  Request_SubSecond_Cnt       BIGINT compress (null, 0)
        ,Statement_SubSecond_Cnt       BIGINT compress (null, 0)
        ,  Request_Tactical_Cnt        BIGINT compress (null, 0)
        ,Statement_Tactical_Cnt        BIGINT compress (null, 0)
        ,  Request_Error_Cnt           BIGINT compress (null, 0)
        ,Statement_Error_Cnt           BIGINT compress (null, 0)
        ,  Request_Spool_Error_Cnt     BIGINT compress (null, 0)
        ,Statement_Spool_Error_Cnt     BIGINT compress (null, 0)
        ,  Request_TASM_Abort_Cnt      BIGINT compress (null, 0)
        ,Statement_TASM_Abort_Cnt      BIGINT compress (null, 0)
        ,  Request_Abort_Cnt           BIGINT compress (null, 0)
        ,Statement_Abort_Cnt           BIGINT compress (null, 0)
        ,  Request_NoIO_Cnt            BIGINT compress (null, 0)
        ,Statement_NoIO_Cnt            BIGINT compress (null, 0)
        ,  Request_InMem_Cnt           BIGINT compress (null, 0)
        ,Statement_InMem_Cnt           BIGINT compress (null, 0)
        ,  Request_PhysIO_Cnt          BIGINT compress (null, 0)
        ,Statement_PhysIO_Cnt          BIGINT compress (null, 0)
        ,  Request_AllAMP_Cnt          BIGINT compress (null, 0)
        ,Statement_AllAMP_Cnt          BIGINT compress (null, 0)
        ,  Request_Utility_Cnt         BIGINT compress (null, 0)
        ,Statement_Utility_Cnt         BIGINT compress (null, 0)
        ,  Request_QueryGrid_Cnt       BIGINT compress (null, 0)
        ,Statement_QueryGrid_Cnt       BIGINT compress (null, 0)

        /* ====== Metrics: RunTimes ====== */
        ,DelayTime_Sec                 DECIMAL(18,4) compress (null, 0)
        ,RunTime_Parse_Sec             DECIMAL(18,4) compress (null, 0)
        ,Runtime_AMP_Sec               DECIMAL(18,4) compress (null, 0)
        ,RunTime_Total_Sec             DECIMAL(18,4) compress (null, 0)
        ,TransferTime_Sec              DECIMAL(18,4) compress (null, 0)

        /* ====== Metrics: CPU & IO ====== */
        ,CPU_Total_Sec                 DECIMAL(18,4) compress (null, 0)
        ,CPU_AMP_Sec                   DECIMAL(18,4) compress (null, 0)
        ,IO_Total_CntM                 DECIMAL(38,4) compress (null, 0)
        ,IO_Physical_CntM              DECIMAL(38,4) compress (null, 0)
        ,IO_Total_GB                   DECIMAL(38,4) compress (null, 0)
        ,IO_Physical_GB                DECIMAL(38,4) compress (null, 0)
        ,IOTA_Used_CntB                DECIMAL(38,4) compress (null, 0)

        /* ====== Metrics: Other ====== */
        ,Spool_GB                      DECIMAL(18,4) compress (null, 0)
        ,Returned_Row_Cnt              BIGINT        compress (null, 0)
        ,NumOfActiveAMPs_Avg           DECIMAL(18,4) compress (null, 0)
        ,QueryGrid_Bytes               DECIMAL(38,8) compress (null, 0)
        ,CacheMiss_IOCnt_Pct           DECIMAL(18,8) compress (null, 0)
        ,CacheMiss_IOGB_Pct            DECIMAL(18,8) compress (null, 0)
        ,CacheMiss_IOCnt_Score         DECIMAL(18,8) compress (null, 0)
        ,CacheMiss_IOGB_Score          DECIMAL(18,8) compress (null, 0)
        ,Total_AMPs                    SMALLINT
        ,AMP_Use01_Flag                BIGINT  compress (null, 0)
        ,AMP_Use02_Flag                INTEGER compress (null, 0)
        ,AMP_LT10pct_Flag              INTEGER compress (null, 0)
        ,AMP_LT50pct_Flag              INTEGER compress (null, 0)
        ,AMP_All_Flag                  INTEGER compress (null, 0)

        /* ====== Audit Fields ====== */
        ,Insert_TS                     TIMESTAMP(0)
        ,Process_Chunk                 SMALLINT compress(null,0,1,2,3,4,5,6,7,8,9,10,11,12)
      )
       primary index(LogDate, Application, Statement_Bucket, Department {{ ',LogTS' if 'LogTS' in run.included else '' }} {{ ',UserName' if 'UserName' in run.included else '' }})
       on commit preserve rows



# -----------------------------------------------
# ----- Loop Logic for filling vt_dbql_core -----
# -----------------------------------------------

{% for ichunk in range(1, process_chunks+1) %}

- name: "INSERT into vt_DBQL_Core -- from DETAIL (chunk {{ ichunk }} of {{ process_chunks }})"
  connect: source
  execute:
    sql: |
      INSERT INTO vt_dbql_core
        with dbql as(
            select
             {{ dbc.logdt }} as LogDate
            {% if 'LogTS' in run.included %}
            ,cast(cast(cast(starttime as format 'YYYY-MM-DDBHH') AS CHAR(13)) || ':00:00' as timestamp(0))  as LogTS
            {% endif %}
            ,AppID ,StatementType, Statements, StatementGroup
            {{ ',WDName AS Workload_Definition' if 'Workload_Definition' in run.included }}
            ,UserName, ErrorCode, Abortflag, LSN
            ,cast(HashAmp()+1 as Integer) as Total_AMPs

            /* ====== ENHANCED FIELDS ======= */
            ,((FirstStepTime - StartTime    ) HOUR(3) TO SECOND(6)) AS Parse_Time
            ,((FirstRespTime - FirstStepTime) HOUR(3) TO SECOND(6)) AS AMP_Time
            ,((FirstRespTime - StartTime    ) HOUR(3) TO SECOND(6)) AS TotalExec_Time
            ,((COALESCE(LastRespTime,FirstRespTime) - FirstRespTime) HOUR(3) TO SECOND(6)) AS Transfer_Time
            ,cast(DelayTime as decimal(38,4)) as Delaytime_Sec
            ,ZEROIFNULL(CAST(EXTRACT(HOUR FROM Parse_Time)     * 3600 + EXTRACT(MINUTE FROM Parse_Time)     * 60 + EXTRACT(SECOND FROM Parse_Time)     AS FLOAT)) AS ParseTime_Sec
            ,ZEROIFNULL(CAST(EXTRACT(HOUR FROM AMP_Time)       * 3600 + EXTRACT(MINUTE FROM AMP_Time)       * 60 + EXTRACT(SECOND FROM AMP_Time)       AS FLOAT)) AS AMPTime_Sec
            ,ZEROIFNULL(CAST(EXTRACT(HOUR FROM TotalExec_Time) * 3600 + EXTRACT(MINUTE FROM TotalExec_Time) * 60 + EXTRACT(SECOND FROM TotalExec_Time) AS FLOAT)) AS TotalExec_Sec
            ,ZEROIFNULL(CAST(EXTRACT(HOUR FROM Transfer_Time)  * 3600 + EXTRACT(MINUTE FROM Transfer_Time)  * 60 + EXTRACT(SECOND FROM Transfer_Time)  AS FLOAT)) AS TransferTime_Sec
            ,case when TotalServerByteCount=0 then 0 else 1 end as QueryGrid_Flag
            ,case when TotalExec_Sec <= 1.00000 then 1 else 0 end as SubSecond_Flag
            ,case when d.StatementType = 'Select' and d.NumOfActiveAMPs < (Total_AMPs * 0.10) and SubSecond_Flag = 1 then 1 else 0 end  as Tactical_Flag
            ,cast(case when d.NumOfActiveAMPs = 1                                 then 1 else 0 end as byteint) as AMP_Use01_Flag
            ,cast(case when d.NumOfActiveAMPs = 2                                 then 1 else 0 end as byteint) as AMP_Use02_Flag
            ,cast(case when d.NumOfActiveAMPs <= cast(Total_AMPs /10 as smallint) then 1 else 0 end as byteint) as AMP_LT10pct_Flag
            ,cast(case when d.NumOfActiveAMPs <= cast(Total_AMPs /50 as smallint) then 1 else 0 end as byteint) as AMP_LT50pct_Flag
            ,cast(case when d.NumOfActiveAMPs = Total_AMPs                        then 1 else 0 end as byteint) as AMP_All_Flag

            {% if "Buckets" in run.included %}
            /* ====== Dimensions: Buckets ====== */
            -- encoded this way to save spool
            {% for metric in bucket_metrics %}
            {% set run.lb=0 %}
            ,cast(case when nullifzero( {{ metric.metric }} ) is NULL then 0 -- translates to: '{{ metric.format % 0 }} - {{ metric.format % 0 }}'
              {% for ub in metric.upperbounds %}
                       when {{ metric.metric }} >= {{ metric.format % run.lb }}.0  AND {{ metric.metric }} < {{ metric.format % ub }}.0  then {{ loop.index }}  -- translates to: '{{ metric.format % run.lb }} - {{ metric.format % ub }}'
                       {% set run.lb = ub %}
              {% endfor %}
                       when {{ metric.metric }} >= {{ metric.format % run.lb }}.0  then 99 -- translates to: '{{ metric.format % run.lb }}+'
                       end as byteint) as {{ metric.name }}
            {% endfor %}
            {% endif %}

            /* ====== Metrics: CPU & IO ====== */
            ,zeroifnull((cast(ParserCPUTime as decimal(18,3)))) as CPU_Parse_Sec
            ,zeroifnull((cast(AMPCPUTime    as decimal(18,3)))) as CPU_AMP_Sec
            ,CPU_Parse_Sec + CPU_AMP_Sec as CPU_Total_Sec
            ,case when TotalIOCount >(10**38) then 0 else TotalIOCount end as TotalIOCount_
            ,case when ReqIOKB      >(10**38) then 0 else ReqIOKB      end as ReqIOKB_
            ,case when ReqPhysIO    >(10**38) then 0 else ReqPhysIO    end as ReqPhysIO_
            ,case when ReqPhysIOKB  >(10**38) then 0 else ReqPhysIOKB  end as ReqPhysIOKB_
            {% if td15 %}
            ,0 as UsedIota_
            {% else %}
            ,case when UsedIota     >(10**38) then 0 else UsedIota     end as UsedIota_
            {% endif %}

            /* ====== Metrics: Other ====== */
            ,SpoolUsage, NumResultRows, NumOfActiveAMPs, NumSteps, TotalServerByteCount
            from {{ dbc.log }} as d
            where {{ dbc.logdt }} in(Select Calendar_Date from vt_DateDriver where Process_Chunk = {{ ichunk }})

        ),

        app as (Select AppID, AppID_Export, Pattern_Type, AppID_Pattern
                ,Application, Usage as Application_Use, Company as Application_Company
                from vt_decode_appid
        ),

        stm as (Select s.*
                from vt_decode_statement as s
        ),

        usr as (Select UserName as UserName2, FullName, UserType, Organization, Department
                ,Exclude_VantageUnit_Flag, Exclude_Performance_Flag
                from vt_decode_user as u
        )
        ------------------------------------
        ------------------------------------
        Select
        '{{ siteid }}' as Site_ID
        ,LogDate
        {{ ',LogTS' if 'LogTS' in run.included }}
        /* ====== Dimensions: Usage ======= */
        ,Application
        ,Application_Use
        ,Application_Company
        ,Statement_Bucket
        ,Statement_Outcome
        {{ ',Workload_Definition' if 'Workload_Definition' in run.included }}
        {{ ',UserName'            if 'UserName'            in run.included }}
        ,UserType
        ,Organization
        ,Department

        /* ====== Dimensions: Flags ======= */
        {{ ',QueryGrid_Flag'                 if 'QueryGrid_Flag' in run.included }}
        {{ ',SubSecond_Flag'                 if 'SubSecond_Flag' in run.included }}
        {{ ',Tactical_Flag'                  if 'Tactical_Flag'  in run.included }}
        {{ ',usr.Exclude_Performance_Flag'   if 'Exclude_Flag'  in run.included }}
        {{ ',usr.Exclude_VantageUnit_Flag'   if 'Exclude_Flag'  in run.included }}

        {% if "Buckets" in run.included %}
        /* ====== Dimensions: Buckets ====== */
        {% for metric in bucket_metrics %}
        {% set run.lb=0 %}
        ,case   when {{ metric.name }} = 0 then '{{ metric.format % 0 }} - {{ metric.format % 0 }}'
          {% for ub in metric.upperbounds %}
                when {{ metric.name }} = {{ loop.index }} then '{{ metric.format % run.lb }} - {{ metric.format % ub }}'
                {% set run.lb = ub %}
          {% endfor %}
                when {{ metric.name }} = 99  then '{{ metric.format % run.lb }}+'
                end as {{ metric.name }}
        {% endfor %}
        {% endif %}

        /* ====== Request and Statement Counts ======= */
        ,zeroifnull(cast(count(*) as BigInt)) as Request_Total_Cnt
        ,zeroifnull(sum(cast(dbql.Statements as BigInt))) as Statement_Total_Cnt
        ,zeroifnull(sum(cast(case when dbql.StatementGroup like '%=%'       then 1 else 0 end as SmallInt))) as Request_MultiStatement_Cnt
        ,zeroifnull(sum(cast(case when dbql.SubSecond_Flag = 1              then 1               else 0 end as bigint))) as   Request_SubSecond_Cnt
        ,zeroifnull(sum(cast(case when dbql.SubSecond_Flag = 1              then dbql.Statements else 0 end as bigint))) as Statement_SubSecond_Cnt
        ,zeroifnull(sum(cast(case when dbql.Tactical_Flag = 1               then 1               else 0 end as bigint))) as   Request_Tactical_Cnt
        ,zeroifnull(sum(cast(case when dbql.Tactical_Flag = 1               then dbql.Statements else 0 end as bigint))) as Statement_Tactical_Cnt
        ,zeroifnull(sum(cast(case when dbql.ErrorCode not     in(0,3158)    then 1               else 0 end as bigint))) as   Request_Error_Cnt
        ,zeroifnull(sum(cast(case when dbql.ErrorCode not     in(0,3158)    then dbql.Statements else 0 end as bigint))) as Statement_Error_Cnt
        ,zeroifnull(sum(cast(case when dbql.ErrorCode         in(2646)      then 1               else 0 end as bigint))) as   Request_Spool_Error_Cnt
        ,zeroifnull(sum(cast(case when dbql.ErrorCode         in(2646)      then dbql.Statements else 0 end as bigint))) as Statement_Spool_Error_Cnt
        ,zeroifnull(sum(cast(case when dbql.ErrorCode         in(3158)      then 1               else 0 end as bigint))) as   Request_TASM_Abort_Cnt
        ,zeroifnull(sum(cast(case when dbql.ErrorCode         in(3158)      then dbql.Statements else 0 end as bigint))) as Statement_TASM_Abort_Cnt
        ,zeroifnull(sum(cast(case when dbql.Abortflag = 'T'                 then 1               else 0 end as bigint))) as   Request_Abort_Cnt
        ,zeroifnull(sum(cast(case when dbql.Abortflag = 'T'                 then dbql.Statements else 0 end as bigint))) as Statement_Abort_Cnt
        ,zeroifnull(sum(cast(case when TotalIOCount_ = 0                    then 1               else 0 end as bigint))) as   Request_NoIO_Cnt
        ,zeroifnull(sum(cast(case when TotalIOCount_ = 0                    then dbql.Statements else 0 end as bigint))) as Statement_NoIO_Cnt
        ,zeroifnull(sum(cast(case when TotalIOCount_ > 0 AND ReqPhysIO_ = 0 then 1               else 0 end as bigint))) as   Request_InMem_Cnt
        ,zeroifnull(sum(cast(case when TotalIOCount_ > 0 AND ReqPhysIO_ = 0 then dbql.Statements else 0 end as bigint))) as Statement_InMem_Cnt
        ,zeroifnull(sum(cast(case when TotalIOCount_ > 0 AND ReqPhysIO_ > 0 then 1               else 0 end as bigint))) as   Request_PhysIO_Cnt
        ,zeroifnull(sum(cast(case when TotalIOCount_ > 0 AND ReqPhysIO_ > 0 then dbql.Statements else 0 end as bigint))) as Statement_PhysIO_Cnt
        ,zeroifnull(sum(cast(case when numofactiveamps = hashamp()+1        then 1               else 0 end as bigint))) as   Request_AllAMP_Cnt
        ,zeroifnull(sum(cast(case when numofactiveamps = hashamp()+1        then dbql.Statements else 0 end as bigint))) as Statement_AllAMP_Cnt
        ,zeroifnull(sum(cast(case when (LSN is not null or LSN >0)          then 1               else 0 end as bigint))) as   Request_Utility_Cnt
        ,zeroifnull(sum(cast(case when (LSN is not null or LSN >0)          then dbql.Statements else 0 end as bigint))) as Statement_Utility_Cnt
        ,zeroifnull(sum(cast( QueryGrid_Flag                                                                as bigint))) as    Request_QueryGrid_Cnt
        ,zeroifnull(sum(cast( case when QueryGrid_Flag = 1                  then Statements      else 0 end as bigint))) as  Statement_QueryGrid_Cnt

        /* ====== Metrics: RunTimes ====== */
        ,sum(cast(DelayTime_Sec           as decimal(36,4))) as DelayTime_Sec
        ,sum(cast(ParseTime_Sec           as decimal(36,4))) as RunTime_Parse_Sec
        ,sum(cast(AMPTime_Sec             as decimal(36,4))) as Runtime_AMP_Sec
        ,sum(cast(TotalExec_Sec           as decimal(36,4))) as RunTime_Total_Sec
        ,sum(cast(TransferTime_Sec        as decimal(36,4))) as TransferTime_Sec

        /* ====== Metrics: CPU & IO ====== */
        ,sum(cast(CPU_Total_Sec           as decimal(18,4))) as CPU_Total_Sec
        ,sum(cast(CPU_AMP_Sec             as decimal(18,4))) as CPU_AMP_Sec
        ,sum(cast(TotalIOCount_ / 1e6     as decimal(38,4))) as IO_Total_CntM
        ,sum(cast(ReqPhysIO_    / 1e6     as decimal(38,4))) as IO_Physical_CntM
        ,sum(cast(ReqIOKB_      / 1e6     as decimal(38,4))) as IO_Total_GB
        ,sum(cast(ReqPhysIOKB_  / 1e6     as decimal(38,4))) as IO_Physical_GB
        ,sum(cast(UsedIota_     / 1e9     as decimal(38,4))) as IOTA_Used_CntB

        /* ====== Metrics: Other ====== */
        ,sum(cast(SpoolUsage /1e9                as decimal(32,4)))     as Spool_GB
        ,sum(cast(NumResultRows                  as bigint))            as Returned_Row_Cnt
        ,cast(avg(NumOfActiveAMPs (float)      ) as decimal(32,4)) as NumOfActiveAMPs_Avg
        ,cast(sum(TotalServerByteCount (float) ) as decimal(38,4)) as QueryGrid_Bytes
        ,zeroifnull(cast(sum(ReqPhysIO_)   as float) / nullifzero(cast(nullifzero(sum(TotalIOCount_)) as float))) as CacheMiss_CntPct
        ,zeroifnull(cast(sum(ReqPhysIOKB_) as float) / nullifzero(cast(nullifzero(sum(ReqIOKB_))      as float))) as CacheMiss_SizePct
        ,case
         when CacheMiss_CntPct <= 0.20 then 0                   /* set score = 0 when less than industry average 20% */
         when CacheMiss_CntPct >= 1.00 then 10                  /* sometimes get Physical > Logical, set to ceiling */
         else cast((CacheMiss_CntPct - 0.20) * 12.5 as integer) /* scale spread of .80 (0.20 to 1.00) to a spread of 10 (1 to 10) */
          end as CacheMiss_CntScore
        ,case
         when CacheMiss_SizePct <= 0.20 then 0                   /* set score = 0 when less than industry average 20% */
         when CacheMiss_SizePct >= 1.00 then 10                  /* sometimes get Physical > Logical, set to ceiling */
         else cast((CacheMiss_SizePct - 0.20) * 12.5 as integer) /* scale spread of .80 (0.20 to 1.00) to a spread of 10 (1 to 10) */
          end as CacheMiss_SizeScore
        ,Total_AMPs
        ,zeroifnull(sum(cast(AMP_Use01_Flag   as BigInt)))  as AMP_Use01_Flag
        ,zeroifnull(sum(cast(AMP_Use02_Flag   as integer))) as AMP_Use02_Flag
        ,zeroifnull(sum(cast(AMP_LT10pct_Flag as integer))) as AMP_LT10pct_Flag
        ,zeroifnull(sum(cast(AMP_LT50pct_Flag as integer))) as AMP_LT50pct_Flag
        ,zeroifnull(sum(cast(AMP_All_Flag     as integer))) as AMP_All_Flag

        /* ====== Audit Fields ====== */
        ,current_Timestamp(0) as Insert_TS
        ,{{ ichunk }} as Process_Chunk

        from dbql
        join usr             on dbql.UserName = usr.UserName2            --<=== VT is complete 1:1 mapping, Equal Join OK
        join app             on app.AppID = dbql.AppID                   --<=== VT is complete 1:1 mapping, Equal Join OK
        left outer join stm  on dbql.StatementType = stm.Statement_Type  --<=== may be incomplete, Outer Join required

        group by
         LogDate
        {{ ',LogTS' if 'LogTS' in run.included }}
        /* ====== Dimensions: Usage ======= */
        ,Application
        ,Application_Use
        ,Application_Company
        ,Statement_Bucket
        ,Statement_Outcome
        {{ ',Workload_Definition' if 'Workload_Definition' in run.included }}
        {{ ',UserName'            if 'UserName'            in run.included }}
        ,UserType
        ,Organization
        ,Department

        /* ====== Dimensions: Flags ======= */
        {{ ',QueryGrid_Flag'                 if 'QueryGrid_Flag' in run.included }}
        {{ ',SubSecond_Flag'                 if 'SubSecond_Flag' in run.included }}
        {{ ',Tactical_Flag'                  if 'Tactical_Flag'  in run.included }}
        {{ ',usr.Exclude_Performance_Flag'   if 'Exclude_Flag'  in run.included }}
        {{ ',usr.Exclude_VantageUnit_Flag'   if 'Exclude_Flag'  in run.included }}

        {% if "Buckets" in run.included %}
        /* ====== Dimensions: Buckets ====== */
        {% for metric in bucket_metrics %}
        ,{{ metric.name }}
        {% endfor %}
        {% endif %}



- name: "INSERT into vt_DBQL_Core -- from SUMMARY (chunk {{ ichunk }} of {{ process_chunks }})"
  connect: source
  execute:
    sql: |
      INSERT INTO vt_dbql_core  -- summary
        with dbql as(
            Select
             cast({{ 'CollectTimeStamp' if td15 else 'starttime' }} as date) as LogDate
             {% if 'LogTS' in run.included %}
             ,cast(cast(cast(CollectTimeStamp as format 'YYYY-MM-DDBHH') AS CHAR(13)) || ':00:00' as timestamp(0))  as LogTS
             {% endif %}
            ,AppID, QueryCount as Statements, {{ "'Summary Queries'" if td15 else "UserName" }} as UserName, 0 as ErrorCode, '' as Abortflag, 0 as LSN

            /* ====== ENHANCED FIELDS ======= */
            ,cast(HashAmp()+1 as Integer) as Total_AMPs
            ,cast(null as interval HOUR(3) TO SECOND(6)) as Parse_Time
            ,cast(null as interval HOUR(3) TO SECOND(6)) as AMP_Time
            ,cast(null as interval HOUR(3) TO SECOND(6)) as TotalExec_Time
            ,cast(null as interval HOUR(3) TO SECOND(6)) as Transfer_Time
            ,0 as Delaytime_Sec
            ,0 as ParseTime_Sec
            ,0 as AMPTime_Sec
            ,zeroifnull(cast(smry.QuerySeconds as decimal(38,2))) as TotalExec_Sec
            ,0 as TransferTime_Sec
            ,0 as QueryGrid_Flag
            ,zeroifnull(case when (cast(TotalExec_Sec as float) / nullifzero(cast(QueryCount as float))) <= 1.00000 then 1 else 0 end) as SubSecond_Flag
            ,SubSecond_Flag as Tactical_Flag

            /* ====== Metrics: CPU & IO ====== */
            ,zeroifnull((cast(ParserCPUTime as decimal(38,3)))) as CPU_Parse_Sec
            ,zeroifnull((cast(AMPCPUTime    as decimal(38,3)))) as CPU_AMP_Sec
            ,CPU_Parse_Sec + CPU_AMP_Sec as CPU_Total_Sec
            ,case when TotalIOCount     >(10**38) then 0 else TotalIOCount end as TotalIOCount_
            {% if td15 %}
            ,0 as ReqPhysIO_
            ,0 as ReqIOKB_
            ,0 as ReqPhysIOKB_
            {% else %}
            ,cast(case when ReqPhysIO   >(10**38) then 0 else ReqPhysIO   end as bigint       ) as ReqPhysIO_
            ,cast(0                                                           as bigint       ) as ReqIOKB_
            ,cast(case when ReqPhysIOKB >(10**38) then 0 else ReqPhysIOKB end as decimal(38,2)) as ReqPhysIOKB_
            {% endif %}
            {% if td15 %}
            ,0 as UsedIota_
            {% else %}
            ,case when UsedIota     >(10**38) then 0 else UsedIota     end as UsedIota_
            {% endif %}

            /* ====== Metrics: Other ====== */
            ,0 SpoolUsage, 0 NumResultRows, 0 NumOfActiveAMPs, 0 NumSteps, 0 TotalServerByteCount
            From {{ dbc.summary }} smry
            where LogDate in(Select Calendar_Date from vt_DateDriver where Process_Chunk = {{ ichunk }})

        ),

        app as (Select AppID, AppID_Export, Pattern_Type, AppID_Pattern
                ,Application, Usage as Application_Use, Company as Application_Company
                from vt_decode_appid
        ),

        usr as (Select UserName as UserName2, FullName, UserType, Organization, Department
                ,Exclude_VantageUnit_Flag, Exclude_Performance_Flag
                from vt_decode_user as u
        )
        ------------------------------------
        ------------------------------------
        Select
        '{{ siteid }}' as Site_ID
        ,LogDate
        {{ ',LogTS' if 'LogTS' in run.included }}
        /* ====== Dimensions: Usage ======= */
        ,Application
        ,Application_Use
        ,Application_Company
        ,'Summary Queries' as Statement_Bucket
        ,'Summary Queries' as Statement_Outcome
        {{ ",'Summary Queries' as Workload_Definition" if 'Workload_Definition' in run.included }}
        {{ ",UserName"  if 'UserName' in run.included }}
        ,UserType
        ,Organization
        ,Department

        /* ====== Dimensions: Flags ======= */
        {{ ',QueryGrid_Flag'                 if 'QueryGrid_Flag' in run.included }}
        {{ ',SubSecond_Flag'                 if 'SubSecond_Flag' in run.included }}
        {{ ',Tactical_Flag'                  if 'Tactical_Flag'  in run.included }}
        {{ ',usr.Exclude_Performance_Flag'   if 'Exclude_Flag'  in run.included }}
        {{ ',usr.Exclude_VantageUnit_Flag'   if 'Exclude_Flag'  in run.included }}

        {% if "Buckets" in run.included %}
        /* ====== Dimensions: Buckets ====== */
        ,'Summary Queries' as Delaytime_Bucket
        ,'Summary Queries' as ParseTime_Bucket
        ,'Summary Queries' as AMPTime_Bucket
        ,'Summary Queries' as TotalExec_Bucket
        ,'Summary Queries' as TransferTime_Bucket
        ,'Summary Queries' as CPU_Parse_Bucket
        ,'Summary Queries' as CPU_AMP_Bucket
        ,'Summary Queries' as TotalIOC_Bucket
        {% endif %}

        /* ====== Request and Statement Counts ======= */
        ,zeroifnull(cast(count(*) as BigInt)) as Request_Total_Cnt
        ,zeroifnull(sum(cast(dbql.Statements as BigInt))) as Statement_Total_Cnt
        ,0 as Request_MultiStatement_Cnt
        ,zeroifnull(sum(cast(case when dbql.SubSecond_Flag = 1              then 1               else 0 end as bigint))) as   Request_SubSecond_Cnt
        ,zeroifnull(sum(cast(case when dbql.SubSecond_Flag = 1              then dbql.Statements else 0 end as bigint))) as Statement_SubSecond_Cnt
        ,zeroifnull(sum(cast(case when dbql.Tactical_Flag = 1               then 1               else 0 end as bigint))) as   Request_Tactical_Cnt
        ,zeroifnull(sum(cast(case when dbql.Tactical_Flag = 1               then dbql.Statements else 0 end as bigint))) as Statement_Tactical_Cnt
        ,zeroifnull(sum(cast(case when dbql.ErrorCode not     in(0,3158)    then 1               else 0 end as bigint))) as   Request_Error_Cnt
        ,zeroifnull(sum(cast(case when dbql.ErrorCode not     in(0,3158)    then dbql.Statements else 0 end as bigint))) as Statement_Error_Cnt
        ,zeroifnull(sum(cast(case when dbql.ErrorCode         in(2646)      then 1               else 0 end as bigint))) as   Request_Spool_Error_Cnt
        ,zeroifnull(sum(cast(case when dbql.ErrorCode         in(2646)      then dbql.Statements else 0 end as bigint))) as Statement_Spool_Error_Cnt
        ,zeroifnull(sum(cast(case when dbql.ErrorCode         in(3158)      then 1               else 0 end as bigint))) as   Request_TASM_Abort_Cnt
        ,zeroifnull(sum(cast(case when dbql.ErrorCode         in(3158)      then dbql.Statements else 0 end as bigint))) as Statement_TASM_Abort_Cnt
        ,zeroifnull(sum(cast(case when dbql.Abortflag = 'T'                 then 1               else 0 end as bigint))) as   Request_Abort_Cnt
        ,zeroifnull(sum(cast(case when dbql.Abortflag = 'T'                 then dbql.Statements else 0 end as bigint))) as Statement_Abort_Cnt
        ,zeroifnull(sum(cast(case when TotalIOCount_ = 0                    then 1               else 0 end as bigint))) as   Request_NoIO_Cnt
        ,zeroifnull(sum(cast(case when TotalIOCount_ = 0                    then dbql.Statements else 0 end as bigint))) as Statement_NoIO_Cnt
        ,zeroifnull(sum(cast(case when TotalIOCount_ > 0 AND ReqPhysIO_ = 0 then 1               else 0 end as bigint))) as   Request_InMem_Cnt
        ,zeroifnull(sum(cast(case when TotalIOCount_ > 0 AND ReqPhysIO_ = 0 then dbql.Statements else 0 end as bigint))) as Statement_InMem_Cnt
        ,zeroifnull(sum(cast(case when TotalIOCount_ > 0 AND ReqPhysIO_ > 0 then 1               else 0 end as bigint))) as   Request_PhysIO_Cnt
        ,zeroifnull(sum(cast(case when TotalIOCount_ > 0 AND ReqPhysIO_ > 0 then dbql.Statements else 0 end as bigint))) as Statement_PhysIO_Cnt
        ,zeroifnull(sum(cast(case when numofactiveamps = hashamp()+1        then 1               else 0 end as bigint))) as   Request_AllAMP_Cnt
        ,zeroifnull(sum(cast(case when numofactiveamps = hashamp()+1        then dbql.Statements else 0 end as bigint))) as Statement_AllAMP_Cnt
        ,zeroifnull(sum(cast(case when (LSN is not null or LSN >0)          then 1               else 0 end as bigint))) as   Request_Utility_Cnt
        ,zeroifnull(sum(cast(case when (LSN is not null or LSN >0)          then dbql.Statements else 0 end as bigint))) as Statement_Utility_Cnt
        ,zeroifnull(sum(cast( QueryGrid_Flag                                                                as bigint))) as    Request_QueryGrid_Cnt
        ,zeroifnull(sum(cast( case when QueryGrid_Flag = 1                  then Statements      else 0 end as bigint))) as  Statement_QueryGrid_Cnt

        /* ====== Metrics: RunTimes ====== */
        ,sum(cast(DelayTime_Sec             as decimal(36,4))) as DelayTime_Sec
        ,sum(cast(ParseTime_Sec             as decimal(36,4))) as RunTime_Parse_Sec
        ,sum(cast(AMPTime_Sec               as decimal(36,4))) as Runtime_AMP_Sec
        ,sum(cast(TotalExec_Sec             as decimal(36,4))) as RunTime_Total_Sec
        ,sum(cast(TransferTime_Sec          as decimal(36,4))) as TransferTime_Sec

        /* ====== Metrics: CPU & IO ====== */
        ,sum(cast(CPU_Total_Sec             as decimal(18,4))) as CPU_Total_Sec
        ,sum(cast(CPU_AMP_Sec               as decimal(18,4))) as CPU_AMP_Sec
        ,sum(cast(TotalIOCount_ / 1e6       as decimal(38,4))) as IO_Total_CntM
        ,sum(cast(ReqPhysIO_    / 1e6       as decimal(38,4))) as IO_Physical_CntM
        ,sum(cast(ReqIOKB_      / 1e6       as decimal(38,4))) as IO_Total_GB
        ,sum(cast(ReqPhysIOKB_  / 1e6       as decimal(38,4))) as IO_Physical_GB
        ,sum(cast(UsedIota_     / 1e9       as decimal(38,4))) as IOTA_Used_CntB

        /* ====== Metrics: Other ====== */
        ,sum(cast(SpoolUsage /1e9                as decimal(32,4)))     as Spool_GB
        ,sum(cast(NumResultRows                  as bigint))            as Returned_Row_Cnt
        ,cast(avg(NumOfActiveAMPs (float)      ) as decimal(32,4)) as NumOfActiveAMPs_Avg
        ,cast(sum(TotalServerByteCount (float) ) as decimal(38,4)) as QueryGrid_Bytes
        ,zeroifnull(cast(sum(ReqPhysIO_)   as float) / nullifzero(cast(nullifzero(sum(TotalIOCount_)) as float))) as CacheMiss_CntPct
        ,zeroifnull(cast(sum(ReqPhysIOKB_) as float) / nullifzero(cast(nullifzero(sum(ReqIOKB_))      as float))) as CacheMiss_SizePct
        ,case
         when CacheMiss_CntPct <= 0.20 then 0                   /* set score = 0 when less than industry average 20% */
         when CacheMiss_CntPct >= 1.00 then 10                  /* sometimes get Physical > Logical, set to ceiling */
         else cast((CacheMiss_CntPct - 0.20) * 12.5 as integer) /* scale spread of .80 (0.20 to 1.00) to a spread of 10 (1 to 10) */
          end as CacheMiss_CntScore
        ,case
         when CacheMiss_SizePct <= 0.20 then 0                   /* set score = 0 when less than industry average 20% */
         when CacheMiss_SizePct >= 1.00 then 10                  /* sometimes get Physical > Logical, set to ceiling */
         else cast((CacheMiss_SizePct - 0.20) * 12.5 as integer) /* scale spread of .80 (0.20 to 1.00) to a spread of 10 (1 to 10) */
          end as CacheMiss_SizeScore
        ,Total_AMPs
        ,0 as AMP_Use01_Flag
        ,0 as AMP_Use02_Flag
        ,0 as AMP_LT10pct_Flag
        ,0 as AMP_LT50pct_Flag
        ,0 as AMP_All_Flag

        /* ====== Audit Fields ====== */
        ,current_Timestamp(0) as Insert_TS
        ,{{ ichunk }} as Process_Chunk

        from dbql
        join usr             on dbql.UserName = usr.UserName2            --<=== VT is complete 1:1 mapping, Equal Join OK
        join app             on app.AppID = dbql.AppID                   --<=== VT is complete 1:1 mapping, Equal Join OK

        group by
         LogDate
        {{ ',LogTS' if 'LogTS' in run.included }}
        /* ====== Dimensions: Usage ======= */
        ,Application
        ,Application_Use
        ,Application_Company
        {{ ',UserName'            if 'UserName'            in run.included }}
        ,UserType
        ,Organization
        ,Department

        /* ====== Dimensions: Flags ======= */
        {{ ',QueryGrid_Flag'                 if 'QueryGrid_Flag' in run.included }}
        {{ ',SubSecond_Flag'                 if 'SubSecond_Flag' in run.included }}
        {{ ',Tactical_Flag'                  if 'Tactical_Flag'  in run.included }}
        {{ ',usr.Exclude_Performance_Flag'   if 'Exclude_Flag'  in run.included }}
        {{ ',usr.Exclude_VantageUnit_Flag'   if 'Exclude_Flag'  in run.included }}

{% endfor %}



- name: "Collect Stats on vt_dbql_core"
  connect: source
  execute:
    sql: |
      collect stats
         column (LogDate, Application, Statement_Bucket, Department {{ ',LogTS' if 'LogTS' in run.included else '' }} {{ ',UserName' if 'UserName' in run.included else '' }})
        ,column (LogDate)
        ,column (Application)
        ,column (Statement_Bucket)
        ,column (Department)
      on vt_dbql_core



#  RECONCILE
# =================================================================
{% if reconcile %}

- name: "Create RECONCILE Process: vt_dbql_core_reconcile"
  connect: source
  execute:
    sql: |
      Create volatile table vt_dbql_core_reconcile
      (Row_Order      integer
      ,Source_Name    varchar(128)
      ,LogDate_Count  integer
      ,CPU_Sec        decimal(36,3)
      ,Row_Count      bigint)
      no primary index
      on commit preserve rows

- name: "RECONCILE: RAW {{ dbc.log }}"
  connect: source
  execute:
    sql: |
      insert into vt_dbql_core_reconcile
      Select 1 as Row_Order
      ,'RAW {{ dbc.log }}' as Source_Name
      ,count(distinct {{ dbc.logdt }} ) as LogDate_Count
      ,zeroifnull(sum(AMPCPUtime+ParserCPUTime)(decimal(36,3))) as CPU_AMP_Sec
      ,count(*) as row_count
      from {{ dbc.log }}
      where {{ dbc.logdt }} between {{ startdate | default('DATE-91') }} and {{ enddate | default('DATE-1') }}

- name: "RECONCILE: RAW {{ dbc.summary }}"
  connect: source
  execute:
    sql: |
      insert into vt_dbql_core_reconcile
      Select 2 as Row_Order
      ,'RAW {{ dbc.summary }}' as Source_Name
      ,count(distinct cast({{ 'CollectTimeStamp' if td15 else 'starttime' }} as date) ) as LogDate_Count
      ,zeroifnull(sum(AMPCPUtime+ParserCPUTime)(decimal(36,3))) as CPU_AMP_Sec
      ,count(*) as row_count
      from {{ dbc.summary }}
      where cast({{ 'CollectTimeStamp' if td15 else 'starttime' }} as date) between {{ startdate | default('DATE-91') }} and {{ enddate | default('DATE-1') }}

- name: "RECONCILE: DBQLogTbl + DBQLSummary"
  connect: source
  execute:
    sql: |
      insert into vt_dbql_core_reconcile
      select 3, 'DBQLogTbl + DBQLSummary'
      ,max(LogDate_Count), sum(CPU_Sec), sum(Row_Count)
      from vt_dbql_core_reconcile
      where Row_Order in(1,2)

- name: "RECONCILE: vt_dbql_core"
  connect: source
  execute:
    sql: |
      insert into vt_dbql_core_reconcile
      Select 4 as Row_Order
      ,'vt_dbql_core' as Source_Name
      ,count(distinct LogDate ) as LogDate_Count
      ,sum(CPU_Total_Sec)(decimal(18,3)) as CPU_AMP_Sec
      ,count(*) as row_count
      from vt_dbql_core

- name: "RECONCILE: Export final records"
  connect: source
  export:
    file: reconcile_DBQL_Core.csv
    sql: Select * from vt_dbql_core_reconcile order by Row_Order

- name: "Drop vt_dbql_core_reconcile"
  connect: source
  execute:
    sql: drop table vt_dbql_core_reconcile

{% endif %}


{% endif %}
{{ run.completed.append('vt_dbql_core') or '' }}
